"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TONClientError = exports.TONContractExitCode = exports.TONErrorCode = exports.TONErrorSource = exports.emptyTONErrorData = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var emptyTONErrorData = {
  core_version: '',
  config_server: '',
  query_url: ''
};
exports.emptyTONErrorData = emptyTONErrorData;
var TONErrorSource = {
  CLIENT: 'client',
  NODE: 'node'
};
exports.TONErrorSource = TONErrorSource;
var TONErrorCode = {
  CLIENT_IS_NOT_SETUP: 1000,
  SEND_NODE_REQUEST_FAILED: 1001,
  MESSAGE_ALREADY_EXPIRED: 1001,
  RUN_LOCAL_ACCOUNT_DOES_NOT_EXISTS: 1002,
  WAIT_FOR_TIMEOUT: 1003,
  INTERNAL_ERROR: 1004,
  QUERY_FAILED: 1005,
  MESSAGE_EXPIRED: 1006,
  SERVER_DOESNT_SUPPORT_AGGREGATIONS: 1007,
  INVALID_CONS: 1008,
  ADDRESS_REQUIRED_FOR_RUN_LOCAL: 1009,
  NETWORK_SILENT: 1010,
  TRANSACTION_LAG: 1011,
  TRANSACTION_WAIT_TIMEOUT: 1012,
  CLOCK_OUT_OF_SYNC: 1013,
  ACCOUNT_MISSING: 1014,
  ACCOUNT_CODE_MISSING: 1015,
  ACCOUNT_BALANCE_TOO_LOW: 1016,
  ACCOUNT_FROZEN_OR_DELETED: 1017,
  // Contracts
  CONTRACT_EXECUTION_FAILED: 3025,
  // Queries
  QUERY_FORCIBLY_ABORTED: 4005
};
exports.TONErrorCode = TONErrorCode;
var TONContractExitCode = {
  REPLAY_PROTECTION: 52,
  MESSAGE_EXPIRED: 57,
  NO_GAS: 13
};
exports.TONContractExitCode = TONContractExitCode;

var TONClientError = /*#__PURE__*/function () {
  function TONClientError(code, message, data, source) {
    _classCallCheck(this, TONClientError);

    _defineProperty(this, "message", void 0);

    _defineProperty(this, "source", void 0);

    _defineProperty(this, "code", void 0);

    _defineProperty(this, "data", void 0);

    this.code = code;
    this.message = message;
    this.data = data;
    this.source = source || TONErrorSource.CLIENT;
  }

  _createClass(TONClientError, null, [{
    key: "isClientError",
    value: function isClientError(error, code) {
      return error.source === TONErrorSource.CLIENT && error.code === code;
    }
  }, {
    key: "isNodeError",
    value: function isNodeError(error, code) {
      return error.source === TONErrorSource.NODE && error.code === code;
    }
  }, {
    key: "isContractError",
    value: function isContractError(error, exitCode) {
      return error.source === TONErrorSource.NODE && error.code === TONErrorCode.CONTRACT_EXECUTION_FAILED && error.data && error.data.exit_code === exitCode;
    }
  }, {
    key: "isOriginalContractError",
    value: function isOriginalContractError(error, exitCode) {
      var _error$data;

      return TONClientError.isContractError(error, exitCode) && !((_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.original_error);
    }
  }, {
    key: "isResolvedContractErrorAfterExpire",
    value: function isResolvedContractErrorAfterExpire(error, exitCode) {
      return TONClientError.isContractError(error, exitCode) && error.data && error.data.original_error && TONClientError.isMessageExpired(error.data.original_error);
    }
  }, {
    key: "internalError",
    value: function internalError(message, data) {
      return new TONClientError(TONErrorCode.INTERNAL_ERROR, "Internal error: ".concat(message), data);
    }
  }, {
    key: "invalidCons",
    value: function invalidCons(data) {
      return new TONClientError(TONErrorCode.INVALID_CONS, 'Invalid CONS structure. Each CONS item must contains of two elements.', data);
    }
  }, {
    key: "sendNodeRequestFailed",
    value: function sendNodeRequestFailed(responseText, data) {
      return new TONClientError(TONErrorCode.SEND_NODE_REQUEST_FAILED, "Send node request failed: ".concat(responseText), data);
    }
  }, {
    key: "runLocalAccountDoesNotExists",
    value: function runLocalAccountDoesNotExists(functionName, address, data) {
      return new TONClientError(TONErrorCode.RUN_LOCAL_ACCOUNT_DOES_NOT_EXISTS, "[".concat(functionName, "] run local failed: account [").concat(address, "] does not exists"), data);
    }
  }, {
    key: "waitForTimeout",
    value: function waitForTimeout(data) {
      return new TONClientError(TONErrorCode.WAIT_FOR_TIMEOUT, 'Wait for operation rejected on timeout', data);
    }
  }, {
    key: "queryFailed",
    value: function queryFailed(errors, data) {
      return new TONClientError(TONErrorCode.QUERY_FAILED, "Query failed: ".concat(errors.map(function (x) {
        return x.message || x.toString();
      }).join('\n')), data);
    }
  }, {
    key: "formatTime",
    value: function formatTime(time) {
      if (time) {
        return "".concat(new Date(time * 1000).toISOString(), " (").concat(time, ")");
      }

      return null;
    }
  }, {
    key: "messageExpired",
    value: function messageExpired(data) {
      return new TONClientError(TONErrorCode.MESSAGE_EXPIRED, 'Message expired', _objectSpread(_objectSpread({}, data), {}, {
        sending_time: TONClientError.formatTime(data.sending_time),
        expiration_time: TONClientError.formatTime(data.expire),
        block_time: TONClientError.formatTime(data.block_time)
      }), TONErrorSource.CLIENT);
    }
  }, {
    key: "serverDoesntSupportAggregations",
    value: function serverDoesntSupportAggregations(data) {
      return new TONClientError(TONErrorCode.SERVER_DOESNT_SUPPORT_AGGREGATIONS, 'Server doesn\'t support aggregations', data);
    }
  }, {
    key: "addressRequiredForRunLocal",
    value: function addressRequiredForRunLocal(data) {
      return new TONClientError(TONErrorCode.ADDRESS_REQUIRED_FOR_RUN_LOCAL, 'Address required for run local. You haven\'t specified contract code or data ' + 'so address is required to load missing parts from network.', data);
    }
  }, {
    key: "networkSilent",
    value: function networkSilent(data) {
      return new TONClientError(TONErrorCode.NETWORK_SILENT, 'Network silent: no blocks produced during timeout.', _objectSpread(_objectSpread({}, data), {}, {
        sending_time: TONClientError.formatTime(data.sending_time),
        expiration_time: TONClientError.formatTime(data.expire)
      }));
    }
  }, {
    key: "transactionWaitTimeout",
    value: function transactionWaitTimeout(data) {
      return new TONClientError(TONErrorCode.TRANSACTION_WAIT_TIMEOUT, 'Transaction did not produced during specified timeout', _objectSpread(_objectSpread({}, data), {}, {
        sending_time: TONClientError.formatTime(data.sending_time)
      }));
    }
  }, {
    key: "clockOutOfSync",
    value: function clockOutOfSync(data) {
      return new TONClientError(TONErrorCode.CLOCK_OUT_OF_SYNC, 'You local clock is out of sync with the server time. ' + 'It is a critical condition for sending messages to the blockchain. ' + 'Please sync you clock with the internet time.', data);
    }
  }, {
    key: "accountMissing",
    value: function accountMissing(address, data) {
      return new TONClientError(TONErrorCode.ACCOUNT_MISSING, "Account with address [".concat(address, "] doesn't exists. ") + 'You have to prepaid this account to have a positive balance on them and then deploy ' + 'a contract code for this account.' + 'See SDK documentation for detailed instructions.', data);
    }
  }, {
    key: "accountCodeMissing",
    value: function accountCodeMissing(address, balance, data) {
      return new TONClientError(TONErrorCode.ACCOUNT_CODE_MISSING, "Account with address [".concat(address, "] exists but haven't a contract code yet. ") + 'You have to ensure that an account has an enough balance for deploying ' + 'a contract code and then deploy a contract code for this account. ' + "Current account balance is [".concat(balance, "]. ") + 'See SDK documentation for detailed instructions.', data);
    }
  }, {
    key: "accountBalanceTooLow",
    value: function accountBalanceTooLow(address, balance, data) {
      return new TONClientError(TONErrorCode.ACCOUNT_BALANCE_TOO_LOW, "Account with address [".concat(address, "] has too low balance [").concat(balance, "]. ") + 'You have to send some value to account balance from other contract ' + '(e.g. Wallet contract). ' + 'See SDK documentation for detailed instructions.', data);
    }
  }, {
    key: "noBlocks",
    value: function noBlocks(workchain, data) {
      var workchainName = workchain === -1 ? 'masterchain' : "workchain ".concat(workchain);
      return new TONClientError(TONErrorCode.NETWORK_SILENT, "\"No blocks for ".concat(workchainName, " found\"."), data);
    }
  }, {
    key: "invalidBlockchain",
    value: function invalidBlockchain(message, data) {
      return new TONClientError(TONErrorCode.NETWORK_SILENT, message, data);
    }
  }, {
    key: "queryForciblyAborted",
    value: function queryForciblyAborted(data) {
      return new TONClientError(TONErrorCode.QUERY_FORCIBLY_ABORTED, 'GraphQL query was forcibly aborted on timeout.', data);
    }
  }, {
    key: "isMessageExpired",
    value: function isMessageExpired(error) {
      return TONClientError.isClientError(error, TONErrorCode.MESSAGE_EXPIRED);
    }
  }, {
    key: "isWaitForTimeout",
    value: function isWaitForTimeout(error) {
      return TONClientError.isClientError(error, TONErrorCode.WAIT_FOR_TIMEOUT);
    }
  }, {
    key: "clientIsNotSetup",
    value: function clientIsNotSetup() {
      return new TONClientError(TONErrorCode.CLIENT_IS_NOT_SETUP, 'TON Client Library isn\'t set up properly', emptyTONErrorData);
    }
  }]);

  return TONClientError;
}();

exports.TONClientError = TONClientError;

_defineProperty(TONClientError, "source", TONErrorSource);

_defineProperty(TONClientError, "code", TONErrorCode);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9UT05DbGllbnRFcnJvci5qcyJdLCJuYW1lcyI6WyJlbXB0eVRPTkVycm9yRGF0YSIsImNvcmVfdmVyc2lvbiIsImNvbmZpZ19zZXJ2ZXIiLCJxdWVyeV91cmwiLCJUT05FcnJvclNvdXJjZSIsIkNMSUVOVCIsIk5PREUiLCJUT05FcnJvckNvZGUiLCJDTElFTlRfSVNfTk9UX1NFVFVQIiwiU0VORF9OT0RFX1JFUVVFU1RfRkFJTEVEIiwiTUVTU0FHRV9BTFJFQURZX0VYUElSRUQiLCJSVU5fTE9DQUxfQUNDT1VOVF9ET0VTX05PVF9FWElTVFMiLCJXQUlUX0ZPUl9USU1FT1VUIiwiSU5URVJOQUxfRVJST1IiLCJRVUVSWV9GQUlMRUQiLCJNRVNTQUdFX0VYUElSRUQiLCJTRVJWRVJfRE9FU05UX1NVUFBPUlRfQUdHUkVHQVRJT05TIiwiSU5WQUxJRF9DT05TIiwiQUREUkVTU19SRVFVSVJFRF9GT1JfUlVOX0xPQ0FMIiwiTkVUV09SS19TSUxFTlQiLCJUUkFOU0FDVElPTl9MQUciLCJUUkFOU0FDVElPTl9XQUlUX1RJTUVPVVQiLCJDTE9DS19PVVRfT0ZfU1lOQyIsIkFDQ09VTlRfTUlTU0lORyIsIkFDQ09VTlRfQ09ERV9NSVNTSU5HIiwiQUNDT1VOVF9CQUxBTkNFX1RPT19MT1ciLCJBQ0NPVU5UX0ZST1pFTl9PUl9ERUxFVEVEIiwiQ09OVFJBQ1RfRVhFQ1VUSU9OX0ZBSUxFRCIsIlFVRVJZX0ZPUkNJQkxZX0FCT1JURUQiLCJUT05Db250cmFjdEV4aXRDb2RlIiwiUkVQTEFZX1BST1RFQ1RJT04iLCJOT19HQVMiLCJUT05DbGllbnRFcnJvciIsImNvZGUiLCJtZXNzYWdlIiwiZGF0YSIsInNvdXJjZSIsImVycm9yIiwiZXhpdENvZGUiLCJleGl0X2NvZGUiLCJpc0NvbnRyYWN0RXJyb3IiLCJvcmlnaW5hbF9lcnJvciIsImlzTWVzc2FnZUV4cGlyZWQiLCJyZXNwb25zZVRleHQiLCJmdW5jdGlvbk5hbWUiLCJhZGRyZXNzIiwiZXJyb3JzIiwibWFwIiwieCIsInRvU3RyaW5nIiwiam9pbiIsInRpbWUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzZW5kaW5nX3RpbWUiLCJmb3JtYXRUaW1lIiwiZXhwaXJhdGlvbl90aW1lIiwiZXhwaXJlIiwiYmxvY2tfdGltZSIsImJhbGFuY2UiLCJ3b3JrY2hhaW4iLCJ3b3JrY2hhaW5OYW1lIiwiaXNDbGllbnRFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVNPLElBQU1BLGlCQUErQixHQUFHO0FBQzNDQyxFQUFBQSxZQUFZLEVBQUUsRUFENkI7QUFFM0NDLEVBQUFBLGFBQWEsRUFBRSxFQUY0QjtBQUczQ0MsRUFBQUEsU0FBUyxFQUFFO0FBSGdDLENBQXhDOztBQU1BLElBQU1DLGNBQWMsR0FBRztBQUMxQkMsRUFBQUEsTUFBTSxFQUFFLFFBRGtCO0FBRTFCQyxFQUFBQSxJQUFJLEVBQUU7QUFGb0IsQ0FBdkI7O0FBS0EsSUFBTUMsWUFBWSxHQUFHO0FBQ3hCQyxFQUFBQSxtQkFBbUIsRUFBRSxJQURHO0FBRXhCQyxFQUFBQSx3QkFBd0IsRUFBRSxJQUZGO0FBR3hCQyxFQUFBQSx1QkFBdUIsRUFBRSxJQUhEO0FBSXhCQyxFQUFBQSxpQ0FBaUMsRUFBRSxJQUpYO0FBS3hCQyxFQUFBQSxnQkFBZ0IsRUFBRSxJQUxNO0FBTXhCQyxFQUFBQSxjQUFjLEVBQUUsSUFOUTtBQU94QkMsRUFBQUEsWUFBWSxFQUFFLElBUFU7QUFReEJDLEVBQUFBLGVBQWUsRUFBRSxJQVJPO0FBU3hCQyxFQUFBQSxrQ0FBa0MsRUFBRSxJQVRaO0FBVXhCQyxFQUFBQSxZQUFZLEVBQUUsSUFWVTtBQVd4QkMsRUFBQUEsOEJBQThCLEVBQUUsSUFYUjtBQVl4QkMsRUFBQUEsY0FBYyxFQUFFLElBWlE7QUFheEJDLEVBQUFBLGVBQWUsRUFBRSxJQWJPO0FBY3hCQyxFQUFBQSx3QkFBd0IsRUFBRSxJQWRGO0FBZXhCQyxFQUFBQSxpQkFBaUIsRUFBRSxJQWZLO0FBZ0J4QkMsRUFBQUEsZUFBZSxFQUFFLElB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T05NZXNzYWdlUHJvY2Vzc2luZ1N0YXRlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBUT05FcnJvckRhdGEgPSB7XG4gICAgY29yZV92ZXJzaW9uOiBzdHJpbmc7XG4gICAgY29uZmlnX3NlcnZlcjogc3RyaW5nO1xuICAgIHF1ZXJ5X3VybDogc3RyaW5nO1xuICAgIFtzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBjb25zdCBlbXB0eVRPTkVycm9yRGF0YTogVE9ORXJyb3JEYXRhID0ge1xuICAgIGNvcmVfdmVyc2lvbjogJycsXG4gICAgY29uZmlnX3NlcnZlcjogJycsXG4gICAgcXVlcnlfdXJsOiAnJyxcbn07XG5cbmV4cG9ydCBjb25zdCBUT05FcnJvclNvdXJjZSA9IHtcbiAgICBDTElFTlQ6ICdjbGllbnQnLFxuICAgIE5PREU6ICdub2RlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBUT05FcnJvckNvZGUgPSB7XG4gICAgQ0xJRU5UX0lTX05PVF9TRVRVUDogMTAwMCxcbiAgICBTRU5EX05PREVfUkVRVUVTVF9GQUlMRUQ6IDEwMDEsXG4gICAgTUVTU0FHRV9BTFJFQURZX0VYUElSRUQ6IDEwMDEsXG4gICAgUlVOX0xPQ0FMX0FDQ09VTlRfRE9FU19OT1RfRVhJU1RTOiAxMDAyLFxuICAgIFdBSVRfRk9SX1RJTUVPVVQ6IDEwMDMsXG4gICAgSU5URVJOQUxfRVJST1I6IDEwMDQsXG4gICAgUVVFUllfRkFJTEVEOiAxMDA1LFxuICAgIE1FU1NBR0VfRVhQSVJFRDogMTAwNixcbiAgICBTRVJWRVJfRE9FU05UX1NVUFBPUlRfQUdHUkVHQVRJT05TOiAxMDA3LFxuICAgIElOVkFMSURfQ09OUzogMTAwOCxcbiAgICBBRERSRVNTX1JFUVVJUkVEX0ZPUl9SVU5fTE9DQUw6IDEwMDksXG4gICAgTkVUV09SS19TSUxFTlQ6IDEwMTAsXG4gICAgVFJBTlNBQ1RJT05fTEFHOiAxMDExLFxuICAgIFRSQU5TQUNUSU9OX1dBSVRfVElNRU9VVDogMTAxMixcbiAgICBDTE9DS19PVVRfT0ZfU1lOQzogMTAxMyxcbiAgICBBQ0NPVU5UX01JU1NJTkc6IDEwMTQsXG4gICAgQUNDT1VOVF9DT0RFX01JU1NJTkc6IDEwMTUsXG4gICAgQUNDT1VOVF9CQUxBTkNFX1RPT19MT1c6IDEwMTYsXG4gICAgQUNDT1VOVF9GUk9aRU5fT1JfREVMRVRFRDogMTAxNyxcblxuICAgIC8vIENvbnRyYWN0c1xuXG4gICAgQ09OVFJBQ1RfRVhFQ1VUSU9OX0ZBSUxFRDogMzAyNSxcblxuICAgIC8vIFF1ZXJpZXNcblxuICAgIFFVRVJZX0ZPUkNJQkxZX0FCT1JURUQ6IDQwMDUsXG59O1xuXG5leHBvcnQgY29uc3QgVE9OQ29udHJhY3RFeGl0Q29kZSA9IHtcbiAgICBSRVBMQVlfUFJPVEVDVElPTjogNTIsXG4gICAgTUVTU0FHRV9FWFBJUkVEOiA1NyxcbiAgICBOT19HQVM6IDEzLFxufTtcblxuZXhwb3J0IGNsYXNzIFRPTkNsaWVudEVycm9yIHtcbiAgICBzdGF0aWMgc291cmNlID0gVE9ORXJyb3JTb3VyY2U7XG4gICAgc3RhdGljIGNvZGUgPSBUT05FcnJvckNvZGU7XG5cbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgc291cmNlOiBzdHJpbmc7XG4gICAgY29kZTogbnVtYmVyO1xuICAgIGRhdGE6IFRPTkVycm9yRGF0YTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjb2RlOiBudW1iZXIsXG4gICAgICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhLFxuICAgICAgICBzb3VyY2U/OiBzdHJpbmcsXG4gICAgKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlIHx8IFRPTkVycm9yU291cmNlLkNMSUVOVDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNDbGllbnRFcnJvcihlcnJvcjogYW55LCBjb2RlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChlcnJvci5zb3VyY2UgPT09IFRPTkVycm9yU291cmNlLkNMSUVOVClcbiAgICAgICAgICAgICYmIChlcnJvci5jb2RlID09PSBjb2RlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNOb2RlRXJyb3IoZXJyb3I6IGFueSwgY29kZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoZXJyb3Iuc291cmNlID09PSBUT05FcnJvclNvdXJjZS5OT0RFKVxuICAgICAgICAgICAgJiYgKGVycm9yLmNvZGUgPT09IGNvZGUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0NvbnRyYWN0RXJyb3IoZXJyb3I6IGFueSwgZXhpdENvZGU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGVycm9yLnNvdXJjZSA9PT0gVE9ORXJyb3JTb3VyY2UuTk9ERSlcbiAgICAgICAgICAgICYmIChlcnJvci5jb2RlID09PSBUT05FcnJvckNvZGUuQ09OVFJBQ1RfRVhFQ1VUSU9OX0ZBSUxFRClcbiAgICAgICAgICAgICYmIChlcnJvci5kYXRhICYmIGVycm9yLmRhdGEuZXhpdF9jb2RlID09PSBleGl0Q29kZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzT3JpZ2luYWxDb250cmFjdEVycm9yKGVycm9yOiBhbnksIGV4aXRDb2RlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIFRPTkNsaWVudEVycm9yLmlzQ29udHJhY3RFcnJvcihlcnJvciwgZXhpdENvZGUpXG4gICAgICAgICAgICAmJiAoIWVycm9yLmRhdGE/Lm9yaWdpbmFsX2Vycm9yKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNSZXNvbHZlZENvbnRyYWN0RXJyb3JBZnRlckV4cGlyZShlcnJvcjogYW55LCBleGl0Q29kZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBUT05DbGllbnRFcnJvci5pc0NvbnRyYWN0RXJyb3IoZXJyb3IsIGV4aXRDb2RlKVxuICAgICAgICAgICAgJiYgKGVycm9yLmRhdGEgJiYgZXJyb3IuZGF0YS5vcmlnaW5hbF9lcnJvclxuICAgICAgICAgICAgICAgICYmIFRPTkNsaWVudEVycm9yLmlzTWVzc2FnZUV4cGlyZWQoZXJyb3IuZGF0YS5vcmlnaW5hbF9lcnJvcikpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpbnRlcm5hbEVycm9yKFxuICAgICAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSxcbiAgICApOiBUT05DbGllbnRFcnJvciB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuSU5URVJOQUxfRVJST1IsXG4gICAgICAgICAgICBgSW50ZXJuYWwgZXJyb3I6ICR7bWVzc2FnZX1gLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW52YWxpZENvbnMoZGF0YTogVE9ORXJyb3JEYXRhKTogVE9OQ2xpZW50RXJyb3Ige1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLklOVkFMSURfQ09OUyxcbiAgICAgICAgICAgICdJbnZhbGlkIENPTlMgc3RydWN0dXJlLiBFYWNoIENPTlMgaXRlbSBtdXN0IGNvbnRhaW5zIG9mIHR3byBlbGVtZW50cy4nLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VuZE5vZGVSZXF1ZXN0RmFpbGVkKFxuICAgICAgICByZXNwb25zZVRleHQ6IHN0cmluZyxcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhLFxuICAgICk6IFRPTkNsaWVudEVycm9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5TRU5EX05PREVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICBgU2VuZCBub2RlIHJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlVGV4dH1gLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcnVuTG9jYWxBY2NvdW50RG9lc05vdEV4aXN0cyhcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBzdHJpbmcsXG4gICAgICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhLFxuICAgICk6IFRPTkNsaWVudEVycm9yIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5SVU5fTE9DQUxfQUNDT1VOVF9ET0VTX05PVF9FWElTVFMsXG4gICAgICAgICAgICBgWyR7ZnVuY3Rpb25OYW1lfV0gcnVuIGxvY2FsIGZhaWxlZDogYWNjb3VudCBbJHthZGRyZXNzfV0gZG9lcyBub3QgZXhpc3RzYCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHdhaXRGb3JUaW1lb3V0KGRhdGE6IFRPTkVycm9yRGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLldBSVRfRk9SX1RJTUVPVVQsXG4gICAgICAgICAgICAnV2FpdCBmb3Igb3BlcmF0aW9uIHJlamVjdGVkIG9uIHRpbWVvdXQnLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcXVlcnlGYWlsZWQoXG4gICAgICAgIGVycm9yczogRXJyb3JbXSxcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhLFxuICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLlFVRVJZX0ZBSUxFRCxcbiAgICAgICAgICAgIGBRdWVyeSBmYWlsZWQ6ICR7ZXJyb3JzLm1hcCh4ID0+IHgubWVzc2FnZSB8fCB4LnRvU3RyaW5nKCkpLmpvaW4oJ1xcbicpfWAsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBmb3JtYXRUaW1lKHRpbWU6ID9udW1iZXIpOiA/c3RyaW5nIHtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtuZXcgRGF0ZSh0aW1lICogMTAwMCkudG9JU09TdHJpbmcoKX0gKCR7dGltZX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWVzc2FnZUV4cGlyZWQoXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSAmIHtcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IHN0cmluZyxcbiAgICAgICAgICAgIHNlbmRpbmdfdGltZTogbnVtYmVyLFxuICAgICAgICAgICAgZXhwaXJlPzogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tfdGltZT86IG51bWJlcixcbiAgICAgICAgICAgIGJsb2NrX2lkPzogc3RyaW5nLFxuICAgICAgICB9LFxuICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLk1FU1NBR0VfRVhQSVJFRCxcbiAgICAgICAgICAgICdNZXNzYWdlIGV4cGlyZWQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2VuZGluZ190aW1lOiBUT05DbGllbnRFcnJvci5mb3JtYXRUaW1lKGRhdGEuc2VuZGluZ190aW1lKSxcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5leHBpcmUpLFxuICAgICAgICAgICAgICAgIGJsb2NrX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5ibG9ja190aW1lKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBUT05FcnJvclNvdXJjZS5DTElFTlQsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlcnZlckRvZXNudFN1cHBvcnRBZ2dyZWdhdGlvbnMoZGF0YTogVE9ORXJyb3JEYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuU0VSVkVSX0RPRVNOVF9TVVBQT1JUX0FHR1JFR0FUSU9OUyxcbiAgICAgICAgICAgICdTZXJ2ZXIgZG9lc25cXCd0IHN1cHBvcnQgYWdncmVnYXRpb25zJyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFkZHJlc3NSZXF1aXJlZEZvclJ1bkxvY2FsKGRhdGE6IFRPTkVycm9yRGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLkFERFJFU1NfUkVRVUlSRURfRk9SX1JVTl9MT0NBTCxcbiAgICAgICAgICAgICdBZGRyZXNzIHJlcXVpcmVkIGZvciBydW4gbG9jYWwuIFlvdSBoYXZlblxcJ3Qgc3BlY2lmaWVkIGNvbnRyYWN0IGNvZGUgb3IgZGF0YSAnXG4gICAgICAgICAgICArICdzbyBhZGRyZXNzIGlzIHJlcXVpcmVkIHRvIGxvYWQgbWlzc2luZyBwYXJ0cyBmcm9tIG5ldHdvcmsuJyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIG5ldHdvcmtTaWxlbnQoXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSAmIHtcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IHN0cmluZyxcbiAgICAgICAgICAgIHNlbmRpbmdfdGltZTogbnVtYmVyLFxuICAgICAgICAgICAgZXhwaXJlOiBudW1iZXIsXG4gICAgICAgICAgICB0aW1lb3V0OiBudW1iZXIsXG4gICAgICAgICAgICBibG9ja19pZD86IHN0cmluZyxcbiAgICAgICAgICAgIG1lc3NhZ2VfcHJvY2Vzc2luZ19zdGF0ZT86IFRPTk1lc3NhZ2VQcm9jZXNzaW5nU3RhdGUsXG4gICAgICAgIH0sXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuTkVUV09SS19TSUxFTlQsXG4gICAgICAgICAgICAnTmV0d29yayBzaWxlbnQ6IG5vIGJsb2NrcyBwcm9kdWNlZCBkdXJpbmcgdGltZW91dC4nLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2VuZGluZ190aW1lOiBUT05DbGllbnRFcnJvci5mb3JtYXRUaW1lKGRhdGEuc2VuZGluZ190aW1lKSxcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5leHBpcmUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdHJhbnNhY3Rpb25XYWl0VGltZW91dChcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhICYge1xuICAgICAgICAgICAgbWVzc2FnZV9pZDogc3RyaW5nLFxuICAgICAgICAgICAgc2VuZGluZ190aW1lOiBudW1iZXIsXG4gICAgICAgICAgICB0aW1lb3V0OiBudW1iZXIsXG4gICAgICAgICAgICBtZXNzYWdlX3Byb2Nlc3Npbmdfc3RhdGU/OiBUT05NZXNzYWdlUHJvY2Vzc2luZ1N0YXRlLFxuICAgICAgICB9LFxuICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLlRSQU5TQUNUSU9OX1dBSVRfVElNRU9VVCxcbiAgICAgICAgICAgICdUcmFuc2FjdGlvbiBkaWQgbm90IHByb2R1Y2VkIGR1cmluZyBzcGVjaWZpZWQgdGltZW91dCcsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBzZW5kaW5nX3RpbWU6IFRPTkNsaWVudEVycm9yLmZvcm1hdFRpbWUoZGF0YS5zZW5kaW5nX3RpbWUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xvY2tPdXRPZlN5bmMoZGF0YTogVE9ORXJyb3JEYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuQ0xPQ0tfT1VUX09GX1NZTkMsXG4gICAgICAgICAgICAnWW91IGxvY2FsIGNsb2NrIGlzIG91dCBvZiBzeW5jIHdpdGggdGhlIHNlcnZlciB0aW1lLiAnXG4gICAgICAgICAgICArICdJdCBpcyBhIGNyaXRpY2FsIGNvbmRpdGlvbiBmb3Igc2VuZGluZyBtZXNzYWdlcyB0byB0aGUgYmxvY2tjaGFpbi4gJ1xuICAgICAgICAgICAgKyAnUGxlYXNlIHN5bmMgeW91IGNsb2NrIHdpdGggdGhlIGludGVybmV0IHRpbWUuJyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFjY291bnRNaXNzaW5nKFxuICAgICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSxcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5BQ0NPVU5UX01JU1NJTkcsXG4gICAgICAgICAgICBgQWNjb3VudCB3aXRoIGFkZHJlc3MgWyR7YWRkcmVzc31dIGRvZXNuJ3QgZXhpc3RzLiBgXG4gICAgICAgICAgICArICdZb3UgaGF2ZSB0byBwcmVwYWlkIHRoaXMgYWNjb3VudCB0byBoYXZlIGEgcG9zaXRpdmUgYmFsYW5jZSBvbiB0aGVtIGFuZCB0aGVuIGRlcGxveSAnXG4gICAgICAgICAgICArICdhIGNvbnRyYWN0IGNvZGUgZm9yIHRoaXMgYWNjb3VudC4nXG4gICAgICAgICAgICArICdTZWUgU0RLIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbGVkIGluc3RydWN0aW9ucy4nLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYWNjb3VudENvZGVNaXNzaW5nKFxuICAgICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIGJhbGFuY2U6IHN0cmluZyxcbiAgICAgICAgZGF0YTogVE9ORXJyb3JEYXRhLFxuICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLkFDQ09VTlRfQ09ERV9NSVNTSU5HLFxuICAgICAgICAgICAgYEFjY291bnQgd2l0aCBhZGRyZXNzIFske2FkZHJlc3N9XSBleGlzdHMgYnV0IGhhdmVuJ3QgYSBjb250cmFjdCBjb2RlIHlldC4gYFxuICAgICAgICAgICAgKyAnWW91IGhhdmUgdG8gZW5zdXJlIHRoYXQgYW4gYWNjb3VudCBoYXMgYW4gZW5vdWdoIGJhbGFuY2UgZm9yIGRlcGxveWluZyAnXG4gICAgICAgICAgICArICdhIGNvbnRyYWN0IGNvZGUgYW5kIHRoZW4gZGVwbG95IGEgY29udHJhY3QgY29kZSBmb3IgdGhpcyBhY2NvdW50LiAnXG4gICAgICAgICAgICArIGBDdXJyZW50IGFjY291bnQgYmFsYW5jZSBpcyBbJHtiYWxhbmNlfV0uIGBcbiAgICAgICAgICAgICsgJ1NlZSBTREsgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlsZWQgaW5zdHJ1Y3Rpb25zLicsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBhY2NvdW50QmFsYW5jZVRvb0xvdyhcbiAgICAgICAgYWRkcmVzczogc3RyaW5nLFxuICAgICAgICBiYWxhbmNlOiBzdHJpbmcsXG4gICAgICAgIGRhdGE6IFRPTkVycm9yRGF0YSxcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5BQ0NPVU5UX0JBTEFOQ0VfVE9PX0xPVyxcbiAgICAgICAgICAgIGBBY2NvdW50IHdpdGggYWRkcmVzcyBbJHthZGRyZXNzfV0gaGFzIHRvbyBsb3cgYmFsYW5jZSBbJHtiYWxhbmNlfV0uIGBcbiAgICAgICAgICAgICsgJ1lvdSBoYXZlIHRvIHNlbmQgc29tZSB2YWx1ZSB0byBhY2NvdW50IGJhbGFuY2UgZnJvbSBvdGhlciBjb250cmFjdCAnXG4gICAgICAgICAgICArICcoZS5nLiBXYWxsZXQgY29udHJhY3QpLiAnXG4gICAgICAgICAgICArICdTZWUgU0RLIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbGVkIGluc3RydWN0aW9ucy4nLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbm9CbG9ja3MoXG4gICAgICAgIHdvcmtjaGFpbjogbnVtYmVyLFxuICAgICAgICBkYXRhOiBUT05FcnJvckRhdGEsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IHdvcmtjaGFpbk5hbWUgPSB3b3JrY2hhaW4gPT09IC0xID8gJ21hc3RlcmNoYWluJyA6IGB3b3JrY2hhaW4gJHt3b3JrY2hhaW59YDtcbiAgICAgICAgcmV0dXJuIG5ldyBUT05DbGllbnRFcnJvcihcbiAgICAgICAgICAgIFRPTkVycm9yQ29kZS5ORVRXT1JLX1NJTEVOVCxcbiAgICAgICAgICAgIGBcIk5vIGJsb2NrcyBmb3IgJHt3b3JrY2hhaW5OYW1lfSBmb3VuZFwiLmAsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBpbnZhbGlkQmxvY2tjaGFpbihcbiAgICAgICAgbWVzc2FnZTogc3RyaW5nLFxuICAgICAgICBkYXRhOiBUT05FcnJvckRhdGEsXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoVE9ORXJyb3JDb2RlLk5FVFdPUktfU0lMRU5ULCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcXVlcnlGb3JjaWJseUFib3J0ZWQoZGF0YTogVE9ORXJyb3JEYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgVE9OQ2xpZW50RXJyb3IoXG4gICAgICAgICAgICBUT05FcnJvckNvZGUuUVVFUllfRk9SQ0lCTFlfQUJPUlRFRCxcbiAgICAgICAgICAgICdHcmFwaFFMIHF1ZXJ5IHdhcyBmb3JjaWJseSBhYm9ydGVkIG9uIHRpbWVvdXQuJyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzTWVzc2FnZUV4cGlyZWQoZXJyb3I6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gVE9OQ2xpZW50RXJyb3IuaXNDbGllbnRFcnJvcihlcnJvciwgVE9ORXJyb3JDb2RlLk1FU1NBR0VfRVhQSVJFRCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzV2FpdEZvclRpbWVvdXQoZXJyb3I6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gVE9OQ2xpZW50RXJyb3IuaXNDbGllbnRFcnJvcihlcnJvciwgVE9ORXJyb3JDb2RlLldBSVRfRk9SX1RJTUVPVVQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjbGllbnRJc05vdFNldHVwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRPTkNsaWVudEVycm9yKFxuICAgICAgICAgICAgVE9ORXJyb3JDb2RlLkNMSUVOVF9JU19OT1RfU0VUVVAsXG4gICAgICAgICAgICAnVE9OIENsaWVudCBMaWJyYXJ5IGlzblxcJ3Qgc2V0IHVwIHByb3Blcmx5JyxcbiAgICAgICAgICAgIGVtcHR5VE9ORXJyb3JEYXRhLFxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==